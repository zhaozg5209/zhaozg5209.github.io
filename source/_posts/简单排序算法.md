---
title: 简单排序算法
date: 2018-12-07 09:48:40
tags: 算法
---
### 名词解释
* **稳定**：如果a原本在b的前面，而a=b，排序后a仍然在b的前面；
* **不稳定**：如果a原本在b的前面，而a=b，排序后a可能在b的后面；
* **内排序**：所有排序操作都在内存中完成；
* **外排序**：由于数据太大，因此把数据存储在硬盘中，而排序通过硬和盒内存之间传输数据才能完成；
* **时间复杂度**：一个算法执行完成所耗费的时间；
* **空间复杂度**：一个算法执行完成所耗费的内存大小。
---
### 常见算法总结
![](/简单排序算法/算法总结.png)
### 冒泡排序
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
#### 动图效果
![](/简单排序算法/冒泡排序.gif)
#### 实现代码
```
/**
 * 冒泡排序
 *
 * @param array
 * @return
 */
public static int[] bubbleSort(int[] array) {
    if (array == null) {
        return null;
    }
    if (array.length == 0) {
        return array;
    }
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array.length - 1 - i; j++) {
            if (array[j + 1] < array[j]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
        }
    }
    return array;
}
```
#### 优化
今天在一篇文章中看见这个问题，冒泡算法如何优化，即以上代码是否存在优化空间？
我们可以思考一下这个问题：如果排序前数组为[8,1,2,3,4,5,6,7],经过一次排序后为[1,2,3,4,5,6,7,8],即已经完成排序，但是我们的代码仍然会继续执行，做了很多无用功，
所以我们可以加入一个判断条件：如果一次排序中没有任何一个数据位置发生交换，则数据已经是排序后的结果，无需再进行下去，所以可以按照如下修改:
```
/**
 * 冒泡排序
 *
 * @param array
 * @return
 */
public static int[] bubbleSort(int[] array) {
    if (array == null) {
        return null;
    }
    if (array.length == 0) {
        return array;
    }
    for (int i = 0; i < array.length; i++) {
        boolean flag = false;
        for (int j = 0; j < array.length - 1 - i; j++) {
            if (array[j + 1] < array[j]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
                flag = true;
            }
        }
        if (!flag) {
            return array;
        }
    }
    return array;
}
```
---
### 选择排序
表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。
选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 
#### 动图效果
![](/简单排序算法/选择排序.gif)
#### 实现代码
```
/**
 * 选择排序
 *
 * @param array
 * @return
 */
public static int[] selectSort(int[] array) {
    if (array == null) {
        return null;
    }
    if (array.length == 0) {
        return array;
    }
    for (int i = 0; i < array.length; i++) {
        int mixIndex = i;
        for (int j = i; j < array.length; j++) {
            if (array[j] < array[mixIndex]) {
                mixIndex = j;
            }
            int temp = array[mixIndex];
            array[mixIndex] = array[i];
            array[i] = temp;
        }
    }
    return array;
}
```
---
### 插入排序
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
#### 动图效果
![](/简单排序算法/插入排序.gif)
#### 实现代码
```
/**
 * 插入排序
 *
 * @param array
 * @return
 */
public static int[] insertSort(int[] array) {
    if (array == null) {
        return null;
    }
    if (array.length == 0) {
        return array;
    }
    //第一个不用动 从第二个开始比较
    for (int i = 1; i < array.length; i++) {
        int current = array[i];
        int index = i;
        //依此比较相邻的两个值
        while (index >= 0 && current < array[index - 1]) {
            index--;
            array[index] = array[index - 1];
        }
        array[index] = current;
    }
    return array;
}
```
### 其他排序见参考链接
[参考链接及详情](https://mp.weixin.qq.com/s?__biz=MzAxMjEwMzQ5MA==&mid=2448886426&idx=1&sn=cdb10fbc7ebf4c49ca39613c612d366d&chksm=8fb550b7b8c2d9a176536c73cd9fdea90e94a48bf3990a29ad5004f1762ef53b8768412fe362&scene=21#wechat_redirect)