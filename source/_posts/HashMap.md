---
title: JDK1.8HashMap知识梳理
date: 2018-12-04 17:18:17
tags:
---
### 数据结构
HashMap每一条数据由Node<K,V>存储，数据维护在底层为Node数组，当Hash冲突时，产生单向链表，JDK1.8之后如果链表节点大于或等于8，则将链表改为红黑树。
所以HashMap底层数据结构为 数组+链表+红黑数。
----------
### hash算法
为了使数据趋于均衡的存储，HashMap使用了自己hash算法：
	```
	static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    ```
我们简单看一下，调用了Object的底层hashCode()方法之后，得到一个32位的code，再使用右位移运算与原来的进行异或运算来保证每一位参与运算，降低hash碰撞。
	>>>与>> :位移运算符，>>>无符号位移，意思是无论是负数还是正数，前面加0，
	比如 11111111111111111111111111111111 >>> 16 = 00000000000000001111111111111111
	>>有符号位移，意思是如果是负数前面加1，是正数前面加0，保持原来数据的符号
	异或：区别于 &（与） |（或），相同则为0，不同则为1；如 1^1=0 1^0=1 0^0=1
	如果使用与则数据趋向于0，如果使用或则数据趋向于1，所以使用异或将每一位数据发挥作用，减小hash碰撞的可能性。
	hash碰撞：不同的值得到相同的结果，存放在同一个节点中。
-----------
### 保证数组大小
HashMap提供了多个构造方法，我们可以自己给定初始化数组的大小，但是通过源码我们发现，底层通过一个方法处理了我们传的数组大小参数，如下：
	```
	static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
	```
这个方法是返回一个大于等于当前参数的2的倍数。
--------
### 扩容
当数组达到一定数量之后，就需要扩容，当然我们不可能在数组满了才去扩容，这样可能已经产生了非常多的hash碰撞，所以这个扩容的临界点也是一个问题，
	HashMap采用的是0.75这个比例，即数组被占用的75%则扩容，这个是基于时间和空间的考虑得出的结论，一个比较合适的值。
	而每次扩容的大小则采用的是>>1,即*2。这里为什么使用2倍扩容方案还有一个原因：
	插入元素的hash值是一个32位的int值，而实际当前元素插入table的索引的值为 ：`(n - 1) & hash` n为数组table的大小
	这个操作其实就是取余（%），使用位运算其实是为了效率。但是前提是n必须是2的倍数。
