<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>炉石港湾</title>
  
  <subtitle>喜洋洋</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-21T03:22:09.757Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>赵志刚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stream</title>
    <link href="http://yoursite.com/2019/03/21/Stream/"/>
    <id>http://yoursite.com/2019/03/21/Stream/</id>
    <published>2019-03-21T03:22:09.000Z</published>
    <updated>2019-03-21T03:22:09.757Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/03/21/hello-world/"/>
    <id>http://yoursite.com/2019/03/21/hello-world/</id>
    <published>2019-03-21T03:19:05.089Z</published>
    <updated>2019-03-21T03:19:05.090Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://yoursite.com/2018/12/28/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/28/异常处理/</id>
    <published>2018-12-28T07:12:02.000Z</published>
    <updated>2019-03-21T03:19:05.094Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>mysql知识汇总</title>
    <link href="http://yoursite.com/2018/12/10/mysql%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/12/10/mysql知识汇总/</id>
    <published>2018-12-10T07:44:57.000Z</published>
    <updated>2019-03-21T03:19:05.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么-group-by-和-order-by-会使查询变慢"><a href="#为什么-group-by-和-order-by-会使查询变慢" class="headerlink" title="为什么 group by 和 order by 会使查询变慢?"></a>为什么 group by 和 order by 会使查询变慢?</h3><p>因为这两个操作需要一个临时表来处理查询的结果数据</p><h3 id="谈谈你对索引的理解？"><a href="#谈谈你对索引的理解？" class="headerlink" title="谈谈你对索引的理解？"></a>谈谈你对索引的理解？</h3><p>索引是若干数据行的关键字的列表，查询数据时，通过索引中的关键字可以快速定位到要访问的记录所在的数据块，从而大大减少读取IO的次数，因此可以显著提升性能。</p><h3 id="是不是索引建立得越多越好？"><a href="#是不是索引建立得越多越好？" class="headerlink" title="是不是索引建立得越多越好？"></a>是不是索引建立得越多越好？</h3><p>合理的索引可以提高查询速度，但是索引在增、删、改的时候需要去维护，所以过多的索引会导致其他操作变慢，从而得不偿失。原则上只在查询使用的字段上增加索引。<br>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><h3 id="为什么-UNION-ALL-比-UNION-快？"><a href="#为什么-UNION-ALL-比-UNION-快？" class="headerlink" title="为什么 UNION ALL 比 UNION 快？"></a>为什么 UNION ALL 比 UNION 快？</h3><p>因为在使用UNION的时候，需要删除重复的记录，所以在知道UNION查询的结果没有重复的情况下，一定要使用UNION ALL。</p><h3 id="数据库事务的四个特性及含义"><a href="#数据库事务的四个特性及含义" class="headerlink" title="数据库事务的四个特性及含义"></a>数据库事务的四个特性及含义</h3><p>数据库事务正确执行的4个要素(ACID)：</p><ul><li>原子性(Atomicity)：整个事物中的所有操作，要么全部完成，要的全部失败，不可能停滞在某一环节。如果执行出错则全部回滚(rollback);</li><li>一致性(Correspondence)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li><li>隔离性(Isolation)：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li>持久性(Durability)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h4></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。<br>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表<h4 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h4>事务隔离级别                    脏读    不可重复读    幻读<br>读未提交（read-uncommitted）    是            是         是<br>不可重复读（read-committed）    否            是         是<br>可重复读（repeatable-read）        否            否         是<br>串行化（serializable）            否            否         否<br>mysql默认的事务隔离级别为repeatable-read</li></ul><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/huanongying/p/7021555.html" target="_blank" rel="noopener">事务隔离级别参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么-group-by-和-order-by-会使查询变慢&quot;&gt;&lt;a href=&quot;#为什么-group-by-和-order-by-会使查询变慢&quot; class=&quot;headerlink&quot; title=&quot;为什么 group by 和 order by 会使查询变慢?&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>GIT</title>
    <link href="http://yoursite.com/2018/12/10/GIT/"/>
    <id>http://yoursite.com/2018/12/10/GIT/</id>
    <published>2018-12-10T07:24:14.000Z</published>
    <updated>2019-03-21T03:19:05.086Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单排序算法</title>
    <link href="http://yoursite.com/2018/12/07/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/07/简单排序算法/</id>
    <published>2018-12-07T01:48:40.000Z</published>
    <updated>2019-03-21T03:19:05.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><strong>稳定</strong>：如果a原本在b的前面，而a=b，排序后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序后a可能在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据存储在硬盘中，而排序通过硬和盒内存之间传输数据才能完成；</li><li><strong>时间复杂度</strong>：一个算法执行完成所耗费的时间；</li><li><strong>空间复杂度</strong>：一个算法执行完成所耗费的内存大小。</li></ul><hr><h3 id="常见算法总结"><a href="#常见算法总结" class="headerlink" title="常见算法总结"></a>常见算法总结</h3><p><img src="/简单排序算法/算法总结.png" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="动图效果"><a href="#动图效果" class="headerlink" title="动图效果"></a>动图效果</h4><p><img src="/简单排序算法/冒泡排序.gif" alt=""></p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] bubbleSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; array.length - 1 - i; j++) &#123;</span><br><span class="line">            if (array[j + 1] &lt; array[j]) &#123;</span><br><span class="line">                int temp = array[j + 1];</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>今天在一篇文章中看见这个问题，冒泡算法如何优化，即以上代码是否存在优化空间？<br>我们可以思考一下这个问题：如果排序前数组为[8,1,2,3,4,5,6,7],经过一次排序后为[1,2,3,4,5,6,7,8],即已经完成排序，但是我们的代码仍然会继续执行，做了很多无用功，<br>所以我们可以加入一个判断条件：如果一次排序中没有任何一个数据位置发生交换，则数据已经是排序后的结果，无需再进行下去，所以可以按照如下修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] bubbleSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        for (int j = 0; j &lt; array.length - 1 - i; j++) &#123;</span><br><span class="line">            if (array[j + 1] &lt; array[j]) &#123;</span><br><span class="line">                int temp = array[j + 1];</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            return array;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="动图效果-1"><a href="#动图效果-1" class="headerlink" title="动图效果"></a>动图效果</h4><p><img src="/简单排序算法/选择排序.gif" alt=""></p><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] selectSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        int mixIndex = i;</span><br><span class="line">        for (int j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">            if (array[j] &lt; array[mixIndex]) &#123;</span><br><span class="line">                mixIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            int temp = array[mixIndex];</span><br><span class="line">            array[mixIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="动图效果-2"><a href="#动图效果-2" class="headerlink" title="动图效果"></a>动图效果</h4><p><img src="/简单排序算法/插入排序.gif" alt=""></p><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] insertSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    //第一个不用动 从第二个开始比较</span><br><span class="line">    for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">        int current = array[i];</span><br><span class="line">        int index = i;</span><br><span class="line">        //依此比较相邻的两个值</span><br><span class="line">        while (index &gt;= 0 &amp;&amp; current &lt; array[index - 1]) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            array[index] = array[index - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他排序见参考链接"><a href="#其他排序见参考链接" class="headerlink" title="其他排序见参考链接"></a>其他排序见参考链接</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjEwMzQ5MA==&amp;mid=2448886426&amp;idx=1&amp;sn=cdb10fbc7ebf4c49ca39613c612d366d&amp;chksm=8fb550b7b8c2d9a176536c73cd9fdea90e94a48bf3990a29ad5004f1762ef53b8768412fe362&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考链接及详情</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定&lt;/strong&gt;：如果a原本在b的前面，而a=b，排序后a仍然在b的前面；&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8HashMap知识梳理</title>
    <link href="http://yoursite.com/2018/12/04/HashMap/"/>
    <id>http://yoursite.com/2018/12/04/HashMap/</id>
    <published>2018-12-04T09:18:17.000Z</published>
    <updated>2019-03-21T03:19:05.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashMap每一条数据由Node&lt;K,V&gt;存储，数据维护在底层为Node数组，当Hash冲突时，产生单向链表，JDK1.8之后如果链表节点大于或等于8，则将链表改为红黑树。</p><h2 id="所以HashMap底层数据结构为-数组-链表-红黑数。"><a href="#所以HashMap底层数据结构为-数组-链表-红黑数。" class="headerlink" title="所以HashMap底层数据结构为 数组+链表+红黑数。"></a>所以HashMap底层数据结构为 数组+链表+红黑数。</h2><h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><p>为了使数据趋于均衡的存储，HashMap使用了自己hash算法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们简单看一下，调用了Object的底层hashCode()方法之后，得到一个32位的code，再使用右位移运算与原来的进行异或运算来保证每一位参与运算，降低hash碰撞。<br>    &gt;&gt;&gt;与&gt;&gt; :位移运算符，&gt;&gt;&gt;无符号位移，意思是无论是负数还是正数，前面加0，<br>    比如 11111111111111111111111111111111 &gt;&gt;&gt; 16 = 00000000000000001111111111111111<br>    &gt;&gt;有符号位移，意思是如果是负数前面加1，是正数前面加0，保持原来数据的符号<br>    异或：区别于 &amp;（与） |（或），相同则为0，不同则为1；如 1^1=0 1^0=1 0^0=1<br>    如果使用与则数据趋向于0，如果使用或则数据趋向于1，所以使用异或将每一位数据发挥作用，减小hash碰撞的可能性。</p><pre><code>hash碰撞：不同的值得到相同的结果，存放在同一个节点中。</code></pre><hr><h3 id="保证数组大小"><a href="#保证数组大小" class="headerlink" title="保证数组大小"></a>保证数组大小</h3><p>HashMap提供了多个构造方法，我们可以自己给定初始化数组的大小，但是通过源码我们发现，底层通过一个方法处理了我们传的数组大小参数，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">       int n = cap - 1;</span><br><span class="line">       n |= n &gt;&gt;&gt; 1;</span><br><span class="line">       n |= n &gt;&gt;&gt; 2;</span><br><span class="line">       n |= n &gt;&gt;&gt; 4;</span><br><span class="line">       n |= n &gt;&gt;&gt; 8;</span><br><span class="line">       n |= n &gt;&gt;&gt; 16;</span><br><span class="line">       return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="这个方法是返回一个大于等于当前参数的2的倍数。"><a href="#这个方法是返回一个大于等于当前参数的2的倍数。" class="headerlink" title="这个方法是返回一个大于等于当前参数的2的倍数。"></a>这个方法是返回一个大于等于当前参数的2的倍数。</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当数组达到一定数量之后，就需要扩容，当然我们不可能在数组满了才去扩容，这样可能已经产生了非常多的hash碰撞，所以这个扩容的临界点也是一个问题，<br>    HashMap采用的是0.75这个比例，即数组被占用的75%则扩容，这个是基于时间和空间的考虑得出的结论，一个比较合适的值。<br>    而每次扩容的大小则采用的是&gt;&gt;1,即*2。这里为什么使用2倍扩容方案还有一个原因：<br>    插入元素的hash值是一个32位的int值，而实际当前元素插入table的索引的值为 ：<code>(n - 1) &amp; hash</code> n为数组table的大小<br>    这个操作其实就是取余（%），使用位运算其实是为了效率。但是前提是n必须是2的倍数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;HashMap每一条数据由Node&amp;lt;K,V&amp;gt;存储，数据维护在底层为Node数组，当Hash冲突时，产生单向链表，
      
    
    </summary>
    
    
  </entry>
  
</feed>
