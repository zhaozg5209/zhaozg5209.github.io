<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>炉石港湾</title>
  
  <subtitle>喜洋洋</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-21T07:13:26.532Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>赵志刚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git常用命令</title>
    <link href="http://yoursite.com/2019/03/21/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/03/21/Git常用命令/</id>
    <published>2019-03-21T07:07:26.000Z</published>
    <updated>2019-03-21T07:13:26.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分支操作："><a href="#分支操作：" class="headerlink" title="分支操作："></a>分支操作：</h3><p>git branch 创建分支<br>git branch -b 创建并切换到新建的分支上<br>git checkout 切换分支<br>git branch 查看分支列表<br>git branch -v 查看所有分支的最后一次操作<br>git branch -vv 查看当前分支<br>git brabch -b 分支名 origin/分支名 创建远程分支到本地<br>git branch –merged 查看别的分支和当前分支合并过的分支<br>git branch –no-merged 查看未与当前分支合并的分支<br>git branch -d 分支名 删除本地分支<br>git branch -D 分支名 强行删除分支<br>git branch origin :分支名 删除远处仓库分支<br>git merge 分支名 合并分支到当前分支上</p><h3 id="暂存操作："><a href="#暂存操作：" class="headerlink" title="暂存操作："></a>暂存操作：</h3><p>git stash 暂存当前修改<br>git stash apply 恢复最近的一次暂存<br>git stash pop 恢复暂存并删除暂存记录<br>git stash list 查看暂存列表<br>git stash drop 暂存名(例：stash@{0}) 移除某次暂存<br>git stash clear 清除暂存</p><h3 id="回退操作："><a href="#回退操作：" class="headerlink" title="回退操作："></a>回退操作：</h3><p>git reset –hard HEAD^ 回退到上一个版本<br>git reset –hard ahdhs1(commit_id) 回退到某个版本<br>git checkout – file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)<br>git reset HEAD file 撤回暂存区的文件修改到工作区</p><h3 id="标签操作："><a href="#标签操作：" class="headerlink" title="标签操作："></a>标签操作：</h3><p>git tag 标签名 添加标签(默认对当前版本)<br>git tag 标签名 commit_id 对某一提交记录打标签<br>git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注<br>git tag 列出所有标签列表<br>git show 标签名 查看标签信息<br>git tag -d 标签名 删除本地标签<br>git push origin 标签名 推送标签到远程仓库<br>git push origin –tags 推送所有标签到远程仓库<br>git push origin :refs/tags/标签名 从远程仓库中删除标签</p><p>###常规操作：<br>git push origin test 推送本地分支到远程仓库<br>git rm -r –cached 文件/文件夹名字 取消文件被版本控制<br>git reflog 获取执行过的命令<br>git log –graph 查看分支合并图<br>git merge –no-ff -m ‘合并描述’ 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录<br>git check-ignore -v 文件名 查看忽略规则<br>git add -f 文件名 强制将文件提交</p><h3 id="git创建项目仓库："><a href="#git创建项目仓库：" class="headerlink" title="git创建项目仓库："></a>git创建项目仓库：</h3><p>git init 初始化<br>git remote add origin url 关联远程仓库<br>git pull<br>git fetch 获取远程仓库中所有的分支到本地</p><h3 id="忽略已加入到版本库中的文件："><a href="#忽略已加入到版本库中的文件：" class="headerlink" title="忽略已加入到版本库中的文件："></a>忽略已加入到版本库中的文件：</h3><p>git update-index –assume-unchanged file 忽略单个文件<br>git rm -r –cached 文件/文件夹名字 (. 忽略全部文件)</p><h3 id="取消忽略文件："><a href="#取消忽略文件：" class="headerlink" title="取消忽略文件："></a>取消忽略文件：</h3><p>git update-index –no-assume-unchanged file</p><h3 id="拉取、上传免密码："><a href="#拉取、上传免密码：" class="headerlink" title="拉取、上传免密码："></a>拉取、上传免密码：</h3><p>git config –global credential.helper stor</p><p><a href="原文：http://h5ip.cn/96CR">原文：http://h5ip.cn/96CR</a><br>(作者：命中水)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;分支操作：&quot;&gt;&lt;a href=&quot;#分支操作：&quot; class=&quot;headerlink&quot; title=&quot;分支操作：&quot;&gt;&lt;/a&gt;分支操作：&lt;/h3&gt;&lt;p&gt;git branch 创建分支&lt;br&gt;git branch -b 创建并切换到新建的分支上&lt;br&gt;git check
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Stream</title>
    <link href="http://yoursite.com/2019/03/21/Stream/"/>
    <id>http://yoursite.com/2019/03/21/Stream/</id>
    <published>2019-03-21T03:22:09.000Z</published>
    <updated>2019-03-21T03:22:09.757Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/03/21/hello-world/"/>
    <id>http://yoursite.com/2019/03/21/hello-world/</id>
    <published>2019-03-21T03:19:05.089Z</published>
    <updated>2019-03-21T03:19:05.090Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://yoursite.com/2018/12/28/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/28/异常处理/</id>
    <published>2018-12-28T07:12:02.000Z</published>
    <updated>2019-03-21T03:19:05.094Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>mysql知识汇总</title>
    <link href="http://yoursite.com/2018/12/10/mysql%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/12/10/mysql知识汇总/</id>
    <published>2018-12-10T07:44:57.000Z</published>
    <updated>2019-03-21T03:19:05.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么-group-by-和-order-by-会使查询变慢"><a href="#为什么-group-by-和-order-by-会使查询变慢" class="headerlink" title="为什么 group by 和 order by 会使查询变慢?"></a>为什么 group by 和 order by 会使查询变慢?</h3><p>因为这两个操作需要一个临时表来处理查询的结果数据</p><h3 id="谈谈你对索引的理解？"><a href="#谈谈你对索引的理解？" class="headerlink" title="谈谈你对索引的理解？"></a>谈谈你对索引的理解？</h3><p>索引是若干数据行的关键字的列表，查询数据时，通过索引中的关键字可以快速定位到要访问的记录所在的数据块，从而大大减少读取IO的次数，因此可以显著提升性能。</p><h3 id="是不是索引建立得越多越好？"><a href="#是不是索引建立得越多越好？" class="headerlink" title="是不是索引建立得越多越好？"></a>是不是索引建立得越多越好？</h3><p>合理的索引可以提高查询速度，但是索引在增、删、改的时候需要去维护，所以过多的索引会导致其他操作变慢，从而得不偿失。原则上只在查询使用的字段上增加索引。<br>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><h3 id="为什么-UNION-ALL-比-UNION-快？"><a href="#为什么-UNION-ALL-比-UNION-快？" class="headerlink" title="为什么 UNION ALL 比 UNION 快？"></a>为什么 UNION ALL 比 UNION 快？</h3><p>因为在使用UNION的时候，需要删除重复的记录，所以在知道UNION查询的结果没有重复的情况下，一定要使用UNION ALL。</p><h3 id="数据库事务的四个特性及含义"><a href="#数据库事务的四个特性及含义" class="headerlink" title="数据库事务的四个特性及含义"></a>数据库事务的四个特性及含义</h3><p>数据库事务正确执行的4个要素(ACID)：</p><ul><li>原子性(Atomicity)：整个事物中的所有操作，要么全部完成，要的全部失败，不可能停滞在某一环节。如果执行出错则全部回滚(rollback);</li><li>一致性(Correspondence)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li><li>隔离性(Isolation)：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li>持久性(Durability)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h4></li><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。<br>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表<h4 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h4>事务隔离级别                    脏读    不可重复读    幻读<br>读未提交（read-uncommitted）    是            是         是<br>不可重复读（read-committed）    否            是         是<br>可重复读（repeatable-read）        否            否         是<br>串行化（serializable）            否            否         否<br>mysql默认的事务隔离级别为repeatable-read</li></ul><hr><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/huanongying/p/7021555.html" target="_blank" rel="noopener">事务隔离级别参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么-group-by-和-order-by-会使查询变慢&quot;&gt;&lt;a href=&quot;#为什么-group-by-和-order-by-会使查询变慢&quot; class=&quot;headerlink&quot; title=&quot;为什么 group by 和 order by 会使查询变慢?&quot;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>GIT</title>
    <link href="http://yoursite.com/2018/12/10/GIT/"/>
    <id>http://yoursite.com/2018/12/10/GIT/</id>
    <published>2018-12-10T07:24:14.000Z</published>
    <updated>2019-03-21T07:05:49.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识-Git"><a href="#认识-Git" class="headerlink" title="认识 Git"></a>认识 Git</h2><p>分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。</p><p>这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。下图来源于Git官网。</p><h3 id="Git-的三种状态"><a href="#Git-的三种状态" class="headerlink" title="Git 的三种状态"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p><p>•已提交（committed）：数据已经安全的保存在本地数据库中。<br>•已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。<br>•已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>由此引入 Git 项目的三个工作区域的概念：Git 仓库(.git directoty) 、工作目录(Working Directory) 以及 暂存区域(Staging Area) 。</p><p>基本的 Git 工作流程如下：<br>•在工作目录中修改文件。<br>•暂存文件，将文件的快照放入暂存区域。<br>•提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p><h2 id="Git-使用快速入门"><a href="#Git-使用快速入门" class="headerlink" title="Git 使用快速入门"></a>Git 使用快速入门</h2><h3 id="获取Git"><a href="#获取Git" class="headerlink" title="获取Git"></a>获取Git</h3><ul><li>在现有的目录中初始化仓库：进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 .git 的子目录。</li><li>从一个服务器克隆一个现有的Git仓库：<code>git clone [url] directoryname</code>（directoryname为本地仓库即文件夹的名称，可选）。</li></ul><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><ul><li>检测当前文件状态：<code>git status</code> 。</li><li>提出更改（把它们添加到暂存区）：<code>git add *</code>(所有文件)、<code>git add filename</code> (针对特定文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）。</li><li>忽略文件：.gitignore 文件(可在里面配置不需要提交的文件)。</li><li>提交更新：<code>git commit -m &quot;代码提交日志&quot;</code>（每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit）。</li><li>跳过使用暂存区域更新的方式 : <code>git commit -a -m &quot;代码提交信息&quot;</code>。git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。</li><li>移除文件 ：<code>git rm filename</code> （从暂存区域移除，然后提交。）</li><li>对文件重命名 ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)。</li></ul><h3 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h3><ul><li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<pre><code>`git init` #git初始化</code></pre>  <code>git remote add origin https://github.com/用户名/你的GitHub用户名.github.io.git</code> #添加仓库地址<br>  <code>git checkout -b 分支名</code> #新建分支并切换到新建的分支<br>  <code>git add .</code> #添加所有本地文件到git<br>  <code>git commit -m &quot;这里填写你本次提交的备注，内容随意&quot;</code> #git提交<br>  <code>git push origin 分支名</code> #文件推送到hexo分支<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。git log 会按提交时间列出所有的更新，最近的更新排在最上面。<br>只看某个人的提交记录：<code>git log --author=zhaozg</code></li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。<br>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。<br>创建一个名字叫做 test 的分支：<code>git branch test</code><br>切换到test分支：<code>git checkout test</code><br>创建分支 test 并切换（上面两个的合并）：<code>git checkout -b test</code><br>合并分支到当前分支上：<code>git merge test</code><br>将 test 分支推送到远端仓库（推送成功后其他人可见）：<code>git push origin test</code></p><p><a href="https://mp.weixin.qq.com/s/ylyHOuEPX4tDvOc7-SxMmw" target="_blank" rel="noopener">参考链接:</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;认识-Git&quot;&gt;&lt;a href=&quot;#认识-Git&quot; class=&quot;headerlink&quot; title=&quot;认识 Git&quot;&gt;&lt;/a&gt;认识 Git&lt;/h2&gt;&lt;p&gt;分布式版本控制系统（Distributed Version Control System，简称 DVCS）面
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>简单排序算法</title>
    <link href="http://yoursite.com/2018/12/07/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/07/简单排序算法/</id>
    <published>2018-12-07T01:48:40.000Z</published>
    <updated>2019-03-21T03:19:05.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><strong>稳定</strong>：如果a原本在b的前面，而a=b，排序后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序后a可能在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据存储在硬盘中，而排序通过硬和盒内存之间传输数据才能完成；</li><li><strong>时间复杂度</strong>：一个算法执行完成所耗费的时间；</li><li><strong>空间复杂度</strong>：一个算法执行完成所耗费的内存大小。</li></ul><hr><h3 id="常见算法总结"><a href="#常见算法总结" class="headerlink" title="常见算法总结"></a>常见算法总结</h3><p><img src="/简单排序算法/算法总结.png" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="动图效果"><a href="#动图效果" class="headerlink" title="动图效果"></a>动图效果</h4><p><img src="/简单排序算法/冒泡排序.gif" alt=""></p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] bubbleSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; array.length - 1 - i; j++) &#123;</span><br><span class="line">            if (array[j + 1] &lt; array[j]) &#123;</span><br><span class="line">                int temp = array[j + 1];</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>今天在一篇文章中看见这个问题，冒泡算法如何优化，即以上代码是否存在优化空间？<br>我们可以思考一下这个问题：如果排序前数组为[8,1,2,3,4,5,6,7],经过一次排序后为[1,2,3,4,5,6,7,8],即已经完成排序，但是我们的代码仍然会继续执行，做了很多无用功，<br>所以我们可以加入一个判断条件：如果一次排序中没有任何一个数据位置发生交换，则数据已经是排序后的结果，无需再进行下去，所以可以按照如下修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 冒泡排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] bubbleSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        for (int j = 0; j &lt; array.length - 1 - i; j++) &#123;</span><br><span class="line">            if (array[j + 1] &lt; array[j]) &#123;</span><br><span class="line">                int temp = array[j + 1];</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">                array[j] = temp;</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag) &#123;</span><br><span class="line">            return array;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="动图效果-1"><a href="#动图效果-1" class="headerlink" title="动图效果"></a>动图效果</h4><p><img src="/简单排序算法/选择排序.gif" alt=""></p><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 选择排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] selectSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        int mixIndex = i;</span><br><span class="line">        for (int j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">            if (array[j] &lt; array[mixIndex]) &#123;</span><br><span class="line">                mixIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            int temp = array[mixIndex];</span><br><span class="line">            array[mixIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="动图效果-2"><a href="#动图效果-2" class="headerlink" title="动图效果"></a>动图效果</h4><p><img src="/简单排序算法/插入排序.gif" alt=""></p><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入排序</span><br><span class="line"> *</span><br><span class="line"> * @param array</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static int[] insertSort(int[] array) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (array.length == 0) &#123;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">    //第一个不用动 从第二个开始比较</span><br><span class="line">    for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">        int current = array[i];</span><br><span class="line">        int index = i;</span><br><span class="line">        //依此比较相邻的两个值</span><br><span class="line">        while (index &gt;= 0 &amp;&amp; current &lt; array[index - 1]) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            array[index] = array[index - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他排序见参考链接"><a href="#其他排序见参考链接" class="headerlink" title="其他排序见参考链接"></a>其他排序见参考链接</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjEwMzQ5MA==&amp;mid=2448886426&amp;idx=1&amp;sn=cdb10fbc7ebf4c49ca39613c612d366d&amp;chksm=8fb550b7b8c2d9a176536c73cd9fdea90e94a48bf3990a29ad5004f1762ef53b8768412fe362&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">参考链接及详情</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定&lt;/strong&gt;：如果a原本在b的前面，而a=b，排序后a仍然在b的前面；&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8HashMap知识梳理</title>
    <link href="http://yoursite.com/2018/12/04/HashMap/"/>
    <id>http://yoursite.com/2018/12/04/HashMap/</id>
    <published>2018-12-04T09:18:17.000Z</published>
    <updated>2019-03-21T03:19:05.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashMap每一条数据由Node&lt;K,V&gt;存储，数据维护在底层为Node数组，当Hash冲突时，产生单向链表，JDK1.8之后如果链表节点大于或等于8，则将链表改为红黑树。</p><h2 id="所以HashMap底层数据结构为-数组-链表-红黑数。"><a href="#所以HashMap底层数据结构为-数组-链表-红黑数。" class="headerlink" title="所以HashMap底层数据结构为 数组+链表+红黑数。"></a>所以HashMap底层数据结构为 数组+链表+红黑数。</h2><h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><p>为了使数据趋于均衡的存储，HashMap使用了自己hash算法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">       int h;</span><br><span class="line">       return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>我们简单看一下，调用了Object的底层hashCode()方法之后，得到一个32位的code，再使用右位移运算与原来的进行异或运算来保证每一位参与运算，降低hash碰撞。<br>    &gt;&gt;&gt;与&gt;&gt; :位移运算符，&gt;&gt;&gt;无符号位移，意思是无论是负数还是正数，前面加0，<br>    比如 11111111111111111111111111111111 &gt;&gt;&gt; 16 = 00000000000000001111111111111111<br>    &gt;&gt;有符号位移，意思是如果是负数前面加1，是正数前面加0，保持原来数据的符号<br>    异或：区别于 &amp;（与） |（或），相同则为0，不同则为1；如 1^1=0 1^0=1 0^0=1<br>    如果使用与则数据趋向于0，如果使用或则数据趋向于1，所以使用异或将每一位数据发挥作用，减小hash碰撞的可能性。</p><pre><code>hash碰撞：不同的值得到相同的结果，存放在同一个节点中。</code></pre><hr><h3 id="保证数组大小"><a href="#保证数组大小" class="headerlink" title="保证数组大小"></a>保证数组大小</h3><p>HashMap提供了多个构造方法，我们可以自己给定初始化数组的大小，但是通过源码我们发现，底层通过一个方法处理了我们传的数组大小参数，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">       int n = cap - 1;</span><br><span class="line">       n |= n &gt;&gt;&gt; 1;</span><br><span class="line">       n |= n &gt;&gt;&gt; 2;</span><br><span class="line">       n |= n &gt;&gt;&gt; 4;</span><br><span class="line">       n |= n &gt;&gt;&gt; 8;</span><br><span class="line">       n |= n &gt;&gt;&gt; 16;</span><br><span class="line">       return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="这个方法是返回一个大于等于当前参数的2的倍数。"><a href="#这个方法是返回一个大于等于当前参数的2的倍数。" class="headerlink" title="这个方法是返回一个大于等于当前参数的2的倍数。"></a>这个方法是返回一个大于等于当前参数的2的倍数。</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当数组达到一定数量之后，就需要扩容，当然我们不可能在数组满了才去扩容，这样可能已经产生了非常多的hash碰撞，所以这个扩容的临界点也是一个问题，<br>    HashMap采用的是0.75这个比例，即数组被占用的75%则扩容，这个是基于时间和空间的考虑得出的结论，一个比较合适的值。<br>    而每次扩容的大小则采用的是&gt;&gt;1,即*2。这里为什么使用2倍扩容方案还有一个原因：<br>    插入元素的hash值是一个32位的int值，而实际当前元素插入table的索引的值为 ：<code>(n - 1) &amp; hash</code> n为数组table的大小<br>    这个操作其实就是取余（%），使用位运算其实是为了效率。但是前提是n必须是2的倍数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;HashMap每一条数据由Node&amp;lt;K,V&amp;gt;存储，数据维护在底层为Node数组，当Hash冲突时，产生单向链表，
      
    
    </summary>
    
    
  </entry>
  
</feed>
