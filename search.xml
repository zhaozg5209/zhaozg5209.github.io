<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2019%2F03%2F21%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[分支操作：git branch 创建分支git checkout -b 创建并切换到新建的分支上git checkout 切换分支git branch 查看分支列表git branch -v 查看所有分支的最后一次操作git branch -vv 查看当前分支git branch -b 分支名 origin/分支名 创建远程分支到本地git branch –merged 查看别的分支和当前分支合并过的分支git branch –no-merged 查看未与当前分支合并的分支git branch -d 分支名 删除本地分支git branch -D 分支名 强行删除分支git push origin –delete 分支名 删除远处仓库分支git merge 分支名 合并分支到当前分支上 暂存操作：git stash 暂存当前修改git stash apply 恢复最近的一次暂存git stash pop 恢复暂存并删除暂存记录git stash list 查看暂存列表git stash drop 暂存名(例：stash@{0}) 移除某次暂存git stash clear 清除暂存 回退操作：git reset –hard HEAD^ 回退到上一个版本git reset –hard ahdhs1(commit_id) 回退到某个版本git checkout – file撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)git reset HEAD file 撤回暂存区的文件修改到工作区 标签操作：git tag 标签名 添加标签(默认对当前版本)git tag 标签名 commit_id 对某一提交记录打标签git tag -a 标签名 -m ‘描述’ 创建新标签并增加备注git tag 列出所有标签列表git show 标签名 查看标签信息git tag -d 标签名 删除本地标签git push origin 标签名 推送标签到远程仓库git push origin –tags 推送所有标签到远程仓库git push origin :refs/tags/标签名 从远程仓库中删除标签 常规操作：git push origin test 推送本地分支到远程仓库git rm -r –cached 文件/文件夹名字 取消文件被版本控制git reflog 获取执行过的命令git log –graph 查看分支合并图git merge –no-ff -m ‘合并描述’ 分支名 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录git check-ignore -v 文件名 查看忽略规则git add -f 文件名 强制将文件提交 git创建项目仓库：git init 初始化git remote add origin url 关联远程仓库git pullgit fetch 获取远程仓库中所有的分支到本地 忽略已加入到版本库中的文件：git update-index –assume-unchanged file 忽略单个文件git rm -r –cached 文件/文件夹名字 (. 忽略全部文件) 取消忽略文件：git update-index –no-assume-unchanged file 拉取、上传免密码：git config –global credential.helper stor 原文地址：http://h5ip.cn/96CR]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8中处理集合的优雅姿势——Stream]]></title>
    <url>%2F2019%2F03%2F21%2FStream%2F</url>
    <content type="text"><![CDATA[在Java中，集合和数组是我们经常会用到的数据结构，需要经常对他们做增、删、改、查、聚合、统计、过滤等操作。相比之下，关系型数据库中也同样有这些操作，但是在Java 8之前，集合和数组的处理并不是很便捷。不过，这一问题在Java 8中得到了改善，Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。本文就来介绍下如何使用Stream。特别说明一下，关于Stream的性能及原理不是本文的重点，如果大家感兴趣后面会出文章单独介绍。 Stream介绍Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。 Stream有以下特性及优点： 无存储：Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生：对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。 惰式执行：Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性：Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。我们举一个例子，来看一下到底Stream可以做什么事情：上面的例子中，获取一些带颜色塑料球作为数据源，首先过滤掉红色的、把它们融化成随机的三角形。再过滤器并删除小的三角形。最后计算出剩余图形的周长。如上图，对于流的处理，主要有三种关键性操作：分别是流的创建、中间操作（intermediate operation）以及最终操作(terminal operation)。 Stream的创建1、通过已有的集合来创建流在Java 8中，除了增加了很多Stream相关的类以外，还对集合类自身做了增强，在其中增加了stream方法，可以将一个集合类转换成流。12List&lt;String&gt; strings = Arrays.asList(&quot;Hollis&quot;, &quot;HollisChuang&quot;, &quot;hollis&quot;, &quot;Hello&quot;, &quot;HelloWorld&quot;, &quot;Hollis&quot;);Stream&lt;String&gt; stream = strings.stream(); 以上，通过一个已有的List创建一个流。除此以外，还有一个parallelStream方法，可以为集合创建一个并行流。 这种通过集合创建出一个Stream的方式也是比较常用的一种方式。 2、通过Stream创建流 可以使用Stream类提供的方法，直接返回一个由指定元素组成的流。stream 123456789如以上代码，直接通过of方法，创建并返回一个Stream。## Stream中间操作Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。![](/steam/2.jpg)以下是常用的中间操作列表:![](/steam/operation.jpg)### filterfilter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤掉空字符串： List strings = Arrays.asList(“Hollis”, “”, “HollisChuang”, “H”, “hollis”);strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);//Hollis, , HollisChuang, H, hollis123### mapmap 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数： List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().map( i -&gt; i*i).forEach(System.out::println);//9,4,4,9,49,9,25123### limit/skiplimit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。以下代码片段使用 limit 方法保理4个元素： List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().limit(4).forEach(System.out::println);//3,2,2,3123### sortedsorted 方法用于对流进行排序。以下代码片段使用 sorted 方法进行排序： List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().sorted().forEach(System.out::println);//2,2,3,3,3,5,7123### distinctdistinct主要用来去重，以下代码片段使用 distinct 对元素进行去重： List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);numbers.stream().distinct().forEach(System.out::println);//3,2,7,51234接下来我们通过一个例子和一张图，来演示下，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会发生什么。代码如下： List strings = Arrays.asList(“Hollis”, “HollisChuang”, “hollis”, “Hello”, “HelloWorld”, “Hollis”);Stream s = strings.stream().filter(string -&gt; string.length()&lt;= 6).map(String::length).sorted().limit(3).distinct();12345678910111213141516171819202122过程及每一步得到的结果如下图：![](/steam/result.jpg)## Stream最终操作Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就需要最终操作（terminal operation）最终操作会消耗流，产生一个最终结果。也就是说，在最终操作之后，不能再次使用流，也不能在使用任何中间操作，否则将抛出异常：`java.lang.IllegalStateException: stream has already been operated upon or closed`俗话说，“你永远不会两次踏入同一条河”也正是这个意思。常用的最终操作如下图：![](/steam/resultMethod.jpg)### forEachStream 提供了方法 &apos;forEach&apos; 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：Random random = new Random();random.ints().limit(10).forEach(System.out::println);countcount用来统计流中的元素个数。 List strings = Arrays.asList(“Hollis”, “HollisChuang”, “hollis”,”Hollis666”, “Hello”, “HelloWorld”, “Hollis”);System.out.println(strings.stream().count());//7123### collectcollect就是一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果： List strings = Arrays.asList(“Hollis”, “HollisChuang”, “hollis”,”Hollis666”, “Hello”, “HelloWorld”, “Hollis”);strings = strings.stream().filter(string -&gt; string.startsWith(“Hollis”)).collect(Collectors.toList());System.out.println(strings);//Hollis, HollisChuang, Hollis666, Hollis` 接下来，我们还是使用一张图，来演示下，前文的例子中，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会，在分别使用不同的最终操作可以得到怎样的结果。 下图，展示了文中介绍的所有操作的位置、输入、输出以及使用一个案例展示了其结果。 ##总结本文介绍了Java 8中的Stream 的用途，优点等。还接受了Stream的几种用法，分别是Stream创建、中间操作和最终操作。 Stream的创建有两种方式，分别是通过集合类的stream方法、通过Stream的of方法。 Stream的中间操作可以用来处理Stream，中间操作的输入和输出都是Stream，中间操作可以是过滤、转换、排序等。 Stream的最终操作可以将Stream转成其他形式，如计算出流中元素的个数、将流装换成集合、以及元素的遍历等。 ####本文转载自公众号 Hollis ,作者 Hollis]]></content>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2018%2F12%2F28%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"></content>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql知识汇总]]></title>
    <url>%2F2018%2F12%2F10%2Fmysql%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[为什么 group by 和 order by 会使查询变慢?因为这两个操作需要一个临时表来处理查询的结果数据 谈谈你对索引的理解？索引是若干数据行的关键字的列表，查询数据时，通过索引中的关键字可以快速定位到要访问的记录所在的数据块，从而大大减少读取IO的次数，因此可以显著提升性能。 是不是索引建立得越多越好？合理的索引可以提高查询速度，但是索引在增、删、改的时候需要去维护，所以过多的索引会导致其他操作变慢，从而得不偿失。原则上只在查询使用的字段上增加索引。创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 为什么 UNION ALL 比 UNION 快？因为在使用UNION的时候，需要删除重复的记录，所以在知道UNION查询的结果没有重复的情况下，一定要使用UNION ALL。 数据库事务的四个特性及含义数据库事务正确执行的4个要素(ACID)： 原子性(Atomicity)：整个事物中的所有操作，要么全部完成，要的全部失败，不可能停滞在某一环节。如果执行出错则全部回滚(rollback); 一致性(Correspondence)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性(Isolation)：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性(Durability)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。事务隔离级别事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表MySQL事务隔离级别事务隔离级别 脏读 不可重复读 幻读读未提交（read-uncommitted） 是 是 是不可重复读（read-committed） 否 是 是可重复读（repeatable-read） 否 否 是串行化（serializable） 否 否 否mysql默认的事务隔离级别为repeatable-read 参考链接事务隔离级别参考链接]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT]]></title>
    <url>%2F2018%2F12%2F10%2FGIT%2F</url>
    <content type="text"><![CDATA[认识 Git分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。 这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。下图来源于Git官网。 Git 的三种状态Git 有三种状态，你的文件可能处于其中之一： •已提交（committed）：数据已经安全的保存在本地数据库中。•已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。•已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入 Git 项目的三个工作区域的概念：Git 仓库(.git directoty) 、工作目录(Working Directory) 以及 暂存区域(Staging Area) 。 基本的 Git 工作流程如下：•在工作目录中修改文件。•暂存文件，将文件的快照放入暂存区域。•提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 Git 使用快速入门获取Git 在现有的目录中初始化仓库：进入项目目录运行 git init 命令,该命令将创建一个名为 .git 的子目录。 从一个服务器克隆一个现有的Git仓库：git clone [url] directoryname（directoryname为本地仓库即文件夹的名称，可选）。 记录每次更新到仓库 检测当前文件状态：git status 。 提出更改（把它们添加到暂存区）：git add *(所有文件)、git add filename (针对特定文件)、git add *.txt（支持通配符，所有 .txt 文件）。 忽略文件：.gitignore 文件(可在里面配置不需要提交的文件)。 提交更新：git commit -m &quot;代码提交日志&quot;（每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit）。 跳过使用暂存区域更新的方式 : git commit -a -m &quot;代码提交信息&quot;。git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 移除文件 ：git rm filename （从暂存区域移除，然后提交。） 对文件重命名 ：git mv README.md README(这个命令相当于mv README.md README、git rm README.md、git add README 这三条命令的集合)。 推送改动到远程仓库 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：`git init` #git初始化 git remote add origin https://github.com/用户名/你的GitHub用户名.github.io.git #添加仓库地址 git checkout -b 分支名 #新建分支并切换到新建的分支 git add . #添加所有本地文件到git git commit -m &quot;这里填写你本次提交的备注，内容随意&quot; #git提交 git push origin 分支名 #文件推送到hexo分支查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。git log 会按提交时间列出所有的更新，最近的更新排在最上面。只看某个人的提交记录：git log --author=zhaozg 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。创建一个名字叫做 test 的分支：git branch test切换到test分支：git checkout test创建分支 test 并切换（上面两个的合并）：git checkout -b test合并分支到当前分支上：git merge test将 test 分支推送到远端仓库（推送成功后其他人可见）：git push origin test 参考链接:]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单排序算法]]></title>
    <url>%2F2018%2F12%2F07%2F%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[名词解释 稳定：如果a原本在b的前面，而a=b，排序后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序后a可能在b的后面； 内排序：所有排序操作都在内存中完成； 外排序：由于数据太大，因此把数据存储在硬盘中，而排序通过硬和盒内存之间传输数据才能完成； 时间复杂度：一个算法执行完成所耗费的时间； 空间复杂度：一个算法执行完成所耗费的内存大小。 常见算法总结 冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 动图效果 实现代码123456789101112131415161718192021222324/** * 冒泡排序 * * @param array * @return */public static int[] bubbleSort(int[] array) &#123; if (array == null) &#123; return null; &#125; if (array.length == 0) &#123; return array; &#125; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array.length - 1 - i; j++) &#123; if (array[j + 1] &lt; array[j]) &#123; int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; &#125; &#125; &#125; return array;&#125; 优化今天在一篇文章中看见这个问题，冒泡算法如何优化，即以上代码是否存在优化空间？我们可以思考一下这个问题：如果排序前数组为[8,1,2,3,4,5,6,7],经过一次排序后为[1,2,3,4,5,6,7,8],即已经完成排序，但是我们的代码仍然会继续执行，做了很多无用功，所以我们可以加入一个判断条件：如果一次排序中没有任何一个数据位置发生交换，则数据已经是排序后的结果，无需再进行下去，所以可以按照如下修改:1234567891011121314151617181920212223242526272829/** * 冒泡排序 * * @param array * @return */public static int[] bubbleSort(int[] array) &#123; if (array == null) &#123; return null; &#125; if (array.length == 0) &#123; return array; &#125; for (int i = 0; i &lt; array.length; i++) &#123; boolean flag = false; for (int j = 0; j &lt; array.length - 1 - i; j++) &#123; if (array[j + 1] &lt; array[j]) &#123; int temp = array[j + 1]; array[j + 1] = array[j]; array[j] = temp; flag = true; &#125; &#125; if (!flag) &#123; return array; &#125; &#125; return array;&#125; 选择排序表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 动图效果 实现代码1234567891011121314151617181920212223242526/** * 选择排序 * * @param array * @return */public static int[] selectSort(int[] array) &#123; if (array == null) &#123; return null; &#125; if (array.length == 0) &#123; return array; &#125; for (int i = 0; i &lt; array.length; i++) &#123; int mixIndex = i; for (int j = i; j &lt; array.length; j++) &#123; if (array[j] &lt; array[mixIndex]) &#123; mixIndex = j; &#125; int temp = array[mixIndex]; array[mixIndex] = array[i]; array[i] = temp; &#125; &#125; return array;&#125; 插入排序插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 动图效果 实现代码1234567891011121314151617181920212223242526/** * 插入排序 * * @param array * @return */public static int[] insertSort(int[] array) &#123; if (array == null) &#123; return null; &#125; if (array.length == 0) &#123; return array; &#125; //第一个不用动 从第二个开始比较 for (int i = 1; i &lt; array.length; i++) &#123; int current = array[i]; int index = i; //依此比较相邻的两个值 while (index &gt;= 0 &amp;&amp; current &lt; array[index - 1]) &#123; index--; array[index] = array[index - 1]; &#125; array[index] = current; &#125; return array;&#125; 其他排序见参考链接参考链接及详情]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK1.8HashMap知识梳理]]></title>
    <url>%2F2018%2F12%2F04%2FHashMap%2F</url>
    <content type="text"><![CDATA[数据结构HashMap每一条数据由Node&lt;K,V&gt;存储，数据维护在底层为Node数组，当Hash冲突时，产生单向链表，JDK1.8之后如果链表节点大于或等于8，则将链表改为红黑树。 所以HashMap底层数据结构为 数组+链表+红黑数。hash算法为了使数据趋于均衡的存储，HashMap使用了自己hash算法： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 我们简单看一下，调用了Object的底层hashCode()方法之后，得到一个32位的code，再使用右位移运算与原来的进行异或运算来保证每一位参与运算，降低hash碰撞。 &gt;&gt;&gt;与&gt;&gt; :位移运算符，&gt;&gt;&gt;无符号位移，意思是无论是负数还是正数，前面加0， 比如 11111111111111111111111111111111 &gt;&gt;&gt; 16 = 00000000000000001111111111111111 &gt;&gt;有符号位移，意思是如果是负数前面加1，是正数前面加0，保持原来数据的符号 异或：区别于 &amp;（与） |（或），相同则为0，不同则为1；如 1^1=0 1^0=1 0^0=1 如果使用与则数据趋向于0，如果使用或则数据趋向于1，所以使用异或将每一位数据发挥作用，减小hash碰撞的可能性。 hash碰撞：不同的值得到相同的结果，存放在同一个节点中。 保证数组大小HashMap提供了多个构造方法，我们可以自己给定初始化数组的大小，但是通过源码我们发现，底层通过一个方法处理了我们传的数组大小参数，如下： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 这个方法是返回一个大于等于当前参数的2的倍数。扩容当数组达到一定数量之后，就需要扩容，当然我们不可能在数组满了才去扩容，这样可能已经产生了非常多的hash碰撞，所以这个扩容的临界点也是一个问题， HashMap采用的是0.75这个比例，即数组被占用的75%则扩容，这个是基于时间和空间的考虑得出的结论，一个比较合适的值。 而每次扩容的大小则采用的是&gt;&gt;1,即*2。这里为什么使用2倍扩容方案还有一个原因： 插入元素的hash值是一个32位的int值，而实际当前元素插入table的索引的值为 ：(n - 1) &amp; hash n为数组table的大小 这个操作其实就是取余（%），使用位运算其实是为了效率。但是前提是n必须是2的倍数。]]></content>
  </entry>
</search>
